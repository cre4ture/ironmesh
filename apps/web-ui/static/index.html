<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ironmesh Client</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 1.5rem; background: #fafafa; }
    main { max-width: 960px; margin: 0 auto; }
    section { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; }
    h1, h2 { margin-top: 0; }
    label { display: block; margin: 0.4rem 0 0.2rem; font-weight: 600; }
    input, textarea, button { font: inherit; }
    input, textarea { width: 100%; padding: 0.5rem; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; }
    textarea { min-height: 110px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
    .actions { margin-top: 0.6rem; display: flex; gap: 0.5rem; flex-wrap: wrap; }
    button { padding: 0.5rem 0.8rem; border: 1px solid #888; border-radius: 6px; background: #f5f5f5; cursor: pointer; }
    pre { background: #111; color: #f2f2f2; padding: 0.8rem; border-radius: 6px; overflow: auto; }
    .muted { color: #666; font-size: 0.92rem; }
    .explorer-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
    .explorer { border: 1px solid #ddd; border-radius: 6px; padding: 0.75rem; }
    .explorer h3 { margin: 0 0 0.4rem; }
    .explorer-path { font-size: 0.9rem; color: #444; margin-bottom: 0.4rem; }
    .explorer-list { border: 1px solid #ddd; border-radius: 6px; min-height: 140px; max-height: 260px; overflow: auto; background: #fcfcfc; }
    .explorer-item { display: block; width: 100%; text-align: left; border: 0; border-bottom: 1px solid #eee; background: transparent; padding: 0.45rem 0.55rem; border-radius: 0; }
    .explorer-item:last-child { border-bottom: 0; }
    .explorer-item:hover { background: #f0f0f0; }
    .explorer-empty { padding: 0.55rem; color: #666; }
    .explorer-output { min-height: 120px; }
    @media (max-width: 900px) { .explorer-grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <main>
    <h1>ironmesh Web UI</h1>

    <section>
      <h2>Store: Upload / Download</h2>
      <div class="row">
        <div>
          <label for="put-key">Upload key</label>
          <input id="put-key" placeholder="docs/readme.txt" />
          <label for="put-value">Upload value</label>
          <textarea id="put-value" placeholder="content"></textarea>
          <div class="actions"><button onclick="uploadObject()">Upload</button></div>
        </div>
        <div>
          <label for="get-key">Download key</label>
          <input id="get-key" placeholder="docs/readme.txt" />
          <div class="actions"><button onclick="downloadObject()">Download</button></div>
          <label for="get-value">Downloaded value</label>
          <textarea id="get-value" readonly></textarea>
        </div>
      </div>
    </section>

    <section>
      <h2>Store: Binary File Upload / Download</h2>
      <p class="muted">Supports binary files (e.g. images around 5MB and larger) without text conversion.</p>
      <div class="row">
        <div>
          <label for="binary-upload-key">Upload key</label>
          <input id="binary-upload-key" placeholder="images/photo.jpg" />
          <label for="binary-upload-file">File</label>
          <input id="binary-upload-file" type="file" />
          <div class="actions"><button onclick="uploadBinaryFile()">Upload Binary File</button></div>
        </div>
        <div>
          <label for="binary-download-key">Download key</label>
          <input id="binary-download-key" placeholder="images/photo.jpg" />
          <label for="binary-download-name">Save as filename (optional)</label>
          <input id="binary-download-name" placeholder="photo.jpg" />
          <div class="actions"><button onclick="downloadBinaryFile()">Download Binary File</button></div>
        </div>
      </div>
    </section>

    <section>
      <h2>File Explorer</h2>
      <p class="muted">Keys are treated as virtual paths; <code>/</code> acts as directory separator.</p>
      <div class="explorer-grid">
        <div class="explorer" id="current-explorer"></div>
        <div class="explorer" id="snapshot-explorer"></div>
      </div>
      <div class="explorer" id="version-explorer" style="margin-top: 0.75rem"></div>
    </section>

    <section>
      <h2>Cluster Health and Replication</h2>
      <div class="actions">
        <button onclick="fetchHealth()">Health</button>
        <button onclick="fetchClusterStatus()">Cluster Status</button>
        <button onclick="fetchNodes()">Nodes</button>
        <button onclick="fetchReplicationPlan()">Replication Plan</button>
      </div>
      <pre id="status-output">(no data yet)</pre>
    </section>
  </main>

  <script>
    async function fetchJson(url, options) {
      const response = await fetch(url, options);
      const payload = await response.json();
      if (!response.ok) {
        throw new Error(payload.error || JSON.stringify(payload));
      }
      return payload;
    }

    function show(id, value) {
      document.getElementById(id).textContent =
        typeof value === 'string' ? value : JSON.stringify(value, null, 2);
    }

    async function uploadObject() {
      const key = document.getElementById('put-key').value;
      const value = document.getElementById('put-value').value;
      try {
        const payload = await fetchJson('/api/store/put', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ key, value })
        });
        show('status-output', payload);
      } catch (err) {
        show('status-output', { error: err.message });
      }
    }

    async function downloadObject() {
      const key = document.getElementById('get-key').value;
      try {
        const payload = await fetchJson('/api/store/get?key=' + encodeURIComponent(key));
        document.getElementById('get-value').value = payload.value || '';
        show('status-output', payload);
      } catch (err) {
        show('status-output', { error: err.message });
      }
    }

    async function uploadBinaryFile() {
      const keyInput = document.getElementById('binary-upload-key');
      const fileInput = document.getElementById('binary-upload-file');
      const file = fileInput.files && fileInput.files[0];

      if (!file) {
        show('status-output', { error: 'Please select a file to upload.' });
        return;
      }

      const key = (keyInput.value || file.name || '').trim();
      if (!key) {
        show('status-output', { error: 'Upload key must not be empty.' });
        return;
      }

      try {
        const response = await fetch('/api/store/put-binary?key=' + encodeURIComponent(key), {
          method: 'POST',
          body: file,
          headers: {
            'content-type': file.type || 'application/octet-stream'
          }
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || JSON.stringify(payload));
        }
        keyInput.value = key;
        show('status-output', {
          ...payload,
          uploaded_filename: file.name,
          uploaded_type: file.type || 'application/octet-stream'
        });
      } catch (err) {
        show('status-output', { error: err.message });
      }
    }

    async function downloadBinaryFile() {
      const key = document.getElementById('binary-download-key').value.trim();
      const preferredName = document.getElementById('binary-download-name').value.trim();
      if (!key) {
        show('status-output', { error: 'Download key must not be empty.' });
        return;
      }

      try {
        const response = await fetch('/api/store/get-binary?key=' + encodeURIComponent(key));
        if (!response.ok) {
          let errorPayload;
          try {
            errorPayload = await response.json();
          } catch {
            errorPayload = { error: `HTTP ${response.status}` };
          }
          throw new Error(errorPayload.error || JSON.stringify(errorPayload));
        }

        const blob = await response.blob();
        let filename = preferredName;
        if (!filename) {
          const disposition = response.headers.get('content-disposition') || '';
          const match = disposition.match(/filename="([^"]+)"/i);
          filename = (match && match[1]) || key.split('/').pop() || 'download.bin';
        }

        const objectUrl = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = objectUrl;
        anchor.download = filename;
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        URL.revokeObjectURL(objectUrl);

        show('status-output', {
          key,
          saved_as: filename,
          size_bytes: blob.size,
          type: blob.type || 'application/octet-stream'
        });
      } catch (err) {
        show('status-output', { error: err.message });
      }
    }

    async function listStoreEntries(prefix, snapshot) {
      const query = new URLSearchParams({ depth: '1' });
      if (prefix) query.set('prefix', prefix);
      if (snapshot) query.set('snapshot', snapshot);
      const payload = await fetchJson('/api/store/list?' + query.toString());
      return Array.isArray(payload.entries) ? payload.entries : [];
    }

    function childEntriesForPath(entries, path) {
      const normalized = path ? path.replace(/\/$/, '') + '/' : '';
      return entries
        .filter(entry => {
          const target = entry.path || '';
          if (!normalized) {
            return target.length > 0;
          }
          return target.startsWith(normalized) && target !== normalized;
        })
        .map(entry => {
          const fullPath = entry.path;
          const stripped = normalized ? fullPath.slice(normalized.length) : fullPath;
          const label = stripped.replace(/\/$/, '');
          return {
            label: label.includes('/') ? label.split('/')[0] : label,
            fullPath,
            isDir: entry.entry_type === 'prefix' || fullPath.endsWith('/'),
          };
        })
        .filter((entry, index, arr) => arr.findIndex(other => other.fullPath === entry.fullPath) === index)
        .sort((a, b) => {
          if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
          return a.label.localeCompare(b.label);
        });
    }

    function createExplorer(rootId, options) {
      const root = document.getElementById(rootId);
      let currentPath = '';

      root.innerHTML = `
        <h3>${options.title}</h3>
        ${options.controlsHtml || ''}
        <div class="explorer-path" data-path></div>
        <div class="explorer-list" data-list></div>
        <pre class="explorer-output" data-output>(select a file)</pre>
      `;

      const pathEl = root.querySelector('[data-path]');
      const listEl = root.querySelector('[data-list]');
      const outputEl = root.querySelector('[data-output]');

      function showOutput(value) {
        outputEl.textContent = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
      }

      async function render() {
        pathEl.textContent = currentPath ? `/${currentPath}` : '/';
        listEl.innerHTML = '<div class="explorer-empty">loading...</div>';

        try {
          const entries = await options.loadEntries(currentPath, root);
          const visible = options.transformEntries
            ? options.transformEntries(entries, currentPath)
            : childEntriesForPath(entries, currentPath);

          listEl.innerHTML = '';

          if (currentPath) {
            const upBtn = document.createElement('button');
            upBtn.className = 'explorer-item';
            upBtn.textContent = 'ðŸ“ ..';
            upBtn.onclick = () => {
              const parts = currentPath.split('/').filter(Boolean);
              parts.pop();
              currentPath = parts.join('/');
              render();
            };
            listEl.appendChild(upBtn);
          }

          if (!visible.length) {
            const empty = document.createElement('div');
            empty.className = 'explorer-empty';
            empty.textContent = '(empty)';
            listEl.appendChild(empty);
            return;
          }

          for (const entry of visible) {
            const btn = document.createElement('button');
            btn.className = 'explorer-item';
            btn.textContent = `${entry.isDir ? 'ðŸ“' : 'ðŸ“„'} ${entry.label}`;
            btn.onclick = async () => {
              if (entry.isDir) {
                currentPath = entry.fullPath.replace(/\/$/, '');
                render();
                return;
              }
              showOutput('loading...');
              try {
                const payload = await options.readFile(entry.fullPath, root);
                showOutput(payload);
              } catch (err) {
                showOutput({ error: err.message });
              }
            };
            listEl.appendChild(btn);
          }
        } catch (err) {
          listEl.innerHTML = '<div class="explorer-empty">(failed to load)</div>';
          showOutput({ error: err.message });
        }
      }

      root.refreshExplorer = render;
      render();
      return { refresh: render };
    }

    async function fetchSnapshots() {
      const payload = await fetchJson('/api/snapshots');
      return Array.isArray(payload) ? payload : [];
    }

    async function fetchVersionsForKey(key) {
      return fetchJson('/api/versions?key=' + encodeURIComponent(key));
    }

    function wireExplorers() {
      createExplorer('current-explorer', {
        title: 'Current Data',
        loadEntries: (path) => listStoreEntries(path, null),
        readFile: (fullPath) => fetchJson('/api/store/get?key=' + encodeURIComponent(fullPath)),
      });

      createExplorer('snapshot-explorer', {
        title: 'Snapshots',
        controlsHtml: `
          <label for="snapshot-id">Snapshot ID</label>
          <select id="snapshot-id"></select>
          <p class="muted">Directory listing and reads both use selected snapshot.</p>
        `,
        loadEntries: async (path, root) => {
          const select = root.querySelector('#snapshot-id');
          if (!select.dataset.loaded) {
            const snapshots = await fetchSnapshots();
            select.innerHTML = snapshots
              .map(s => `<option value="${s.id}">${s.id}</option>`)
              .join('') || '<option value="">(no snapshots)</option>';
            select.dataset.loaded = '1';
            select.onchange = () => root.refreshExplorer();
          }
          const snapshotId = select.value;
          return listStoreEntries(path, snapshotId || null);
        },
        readFile: (fullPath, root) => {
          const snapshotId = root.querySelector('#snapshot-id').value;
          const query = new URLSearchParams({ key: fullPath });
          if (snapshotId) query.set('snapshot', snapshotId);
          return fetchJson('/api/store/get?' + query.toString());
        },
      });

      createExplorer('version-explorer', {
        title: 'Earlier Versions',
        controlsHtml: `
          <label for="version-key">Key</label>
          <input id="version-key" placeholder="docs/readme.txt" />
          <div class="actions"><button type="button" id="load-versions">Load Versions</button></div>
        `,
        loadEntries: async (_path, root) => {
          const keyInput = root.querySelector('#version-key');
          const key = keyInput.value.trim();
          const button = root.querySelector('#load-versions');
          if (!button.dataset.wired) {
            button.dataset.wired = '1';
            button.onclick = () => root.refreshExplorer();
          }
          if (!key) {
            return [];
          }

          const graph = await fetchVersionsForKey(key);
          const versions = Array.isArray(graph.versions) ? graph.versions : [];
          return versions.map(v => ({
            path: `${v.version_id}`,
            entry_type: 'key',
            meta: v,
          }));
        },
        transformEntries: (entries) => entries.map(entry => ({
          label: `${entry.path}`,
          fullPath: entry.path,
          isDir: false,
        })),
        readFile: (versionId, root) => {
          const key = root.querySelector('#version-key').value.trim();
          const query = new URLSearchParams({ key, version: versionId });
          return fetchJson('/api/store/get?' + query.toString());
        },
      });
    }

    async function fetchHealth() {
      try { show('status-output', await fetchJson('/api/health')); }
      catch (err) { show('status-output', { error: err.message }); }
    }

    async function fetchClusterStatus() {
      try { show('status-output', await fetchJson('/api/cluster/status')); }
      catch (err) { show('status-output', { error: err.message }); }
    }

    async function fetchNodes() {
      try { show('status-output', await fetchJson('/api/cluster/nodes')); }
      catch (err) { show('status-output', { error: err.message }); }
    }

    async function fetchReplicationPlan() {
      try { show('status-output', await fetchJson('/api/cluster/replication/plan')); }
      catch (err) { show('status-output', { error: err.message }); }
    }

    wireExplorers();
  </script>
</body>
</html>
